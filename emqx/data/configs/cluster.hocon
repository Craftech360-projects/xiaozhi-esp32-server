authentication = [
  {
    backend = http
    body {
      client_id = "${clientid}"
      password = "${password}"
      peerhost = "${peerhost}"
      username = "${username}"
    }
    connect_timeout = "5s"
    enable = true
    enable_pipelining = 100
    headers {
      accept = "application/json"
      cache-control = "no-cache"
      connection = "keep-alive"
      content-type = "application/json"
      keep-alive = "timeout=30, max=1000"
    }
    mechanism = password_based
    method = post
    pool_size = 8
    request_timeout = "10s"
    ssl {
      ciphers = []
      depth = 10
      enable = false
      hibernate_after = "5s"
      log_level = notice
      reuse_sessions = true
      secure_renegotiate = true
      verify = verify_none
      versions = [
        "tlsv1.3",
        "tlsv1.2"
      ]
    }
    url = "http://172.17.0.1:8003/mqtt/auth"
  }
]
rule_engine {
  ignore_sys_message = true
  jq_function_default_timeout = "10s"
  rules {
    device_server_with_client_id {
      actions = [
        {
          args {
            direct_dispatch = false
            mqtt_properties {}
            payload = """~
                {
                  "type": "${type}",
                  "content": "${content}",
                  "timestamp": ${timestamp},
                  "device_id": "${device_id}",
                  "client_id": "${client_id}"
                }~"""
            qos = 0
            retain = false
            topic = "device-server-with-client"
            user_properties = ""
          }
          function = republish
        }
      ]
      description = ""
      metadata {created_at = 1757590553015}
      sql = """~
          SELECT
            clientid,
            payload.type as type,
            payload.content as content,
            payload.timestamp as timestamp,
            payload.device_id as device_id,
            clientid as client_id
          FROM "device-server"~"""
    }
  }
}
